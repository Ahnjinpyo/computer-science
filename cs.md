# Computer Science

## 목차
- [Computer Science](#computer-science)
  - [목차](#목차)
- [데이터베이스](#데이터베이스)
  - [인덱스](#인덱스)
    - [1. 인덱스란](#1-인덱스란)
    - [2. 인덱스 종류](#2-인덱스-종류)
    - [3. B-트리가 데이터베이스 인덱스에 적합한 이유](#3-b-트리가-데이터베이스-인덱스에-적합한-이유)
    - [4. Clustered Index](#4-clustered-index)
    - [5. Non-Clustered Index](#5-non-clustered-index)
    - [6. Composite Index](#6-composite-index)
    - [7. Index의 성능과 고려 사항](#7-index의-성능과-고려-사항)
  - [정규화](#정규화)
    - [1. 배경](#1-배경)
    - [2. 정규화란?](#2-정규화란)
    - [3. 정규화 장점](#3-정규화-장점)
    - [4. 정규화 단점](#4-정규화-단점)
    - [5. 반정규화](#5-반정규화)
  - [Transaction](#transaction)
    - [1. 트랜잭션이란?](#1-트랜잭션이란)
    - [2. 트랜잭션과 Lock](#2-트랜잭션과-lock)
    - [3. 트랜잭션 특성 (ACID)](#3-트랜잭션-특성-acid)
    - [4. 트랜잭션 상태](#4-트랜잭션-상태)
    - [5. 트랜잭션 사용 시 주의사항](#5-트랜잭션-사용-시-주의사항)
    - [6. DeadLock (교착 상태)](#6-deadlock-교착-상태)

<br><br>

# 데이터베이스

## 인덱스
### 1. 인덱스란
- DBMS에서 인덱스란 데이터베이스 테이블의 특정 열 또는 열들의 조합에 대해 생성되는 데이터 구조
- 데이터를 효율적으로 검색하고 접근 속도를 높이기 위해 사용
- 인덱스는 책의 목차처럼 특정 데이터를 빠르게 찾을 수 있게 하며, 일반적으로 B-트리나 해시 테이블 형태로 구현
  
### 2. 인덱스 종류
- B-트리 인덱스
  - 가장 일반적인 인덱스 형태
  - 범위 검색이나 정렬이 필요한 경우에 유리
  - 컬럼의 값을 변형하지 않고, 원래의 값을 이용해 인덱싱하는 알고리즘
- 해시 인덱스
  - 정확히 일치하는 값의 검색에 최적화
  - 범위 검색에는 적합하지 않음
  - 컬럼 값으로 해시 값을 계산해서 인덱싱하는 알고리즘
  - 값을 해시로 변형해서 인덱싱 하므로, 특정 문자로 시작하는 전방일치 검색에는 사용 불가
- 비트맵 인덱스
  - 값의 경우의 수가 적은 경우에 적합
  - OLAP 환경에서 주로 사용
  
### 3. B-트리가 데이터베이스 인덱스에 적합한 이유
- 해시 테이블의 경우 특정 값을 정확히 일치하는 = 동등 연산에는 빠르게 찾을 수 있지만, 비교 연산을 수행하는데는 비적합
- 범위 검색 지원
  - B-트리는 트리 구조를 통해 데이터가 정렬된 상태로 저장되므로 >, <, BETWEEN 등의 범위 조건을 효율적으로 처리
- 균형 유지
  - B-트리는 균형 트리이기 때문에 특정 값에 대한 검색, 삽입, 삭제의 시간 복잡도가 O(logN)으로 일정
- 다양한 조건 처리
  - B-트리는 데이터의 정렬 상태를 유지하면서 저장하므로 정렬 기반 쿼리나 비교 연산을 포함한 쿼리에서도 효율적
- 일치 연산 및 범위 연산 모두 지원
  
 ### 4. Clustered Index
- 물리적 정렬
  - 데이터의 물리적 저장 순서를 정하는 인덱스로, 데이터가 실제로 저장되는 방식에 영향을 줌
  - 즉,Primary Key에 따라 테이블의 행이 정렬
- 속성 변경 시 데이터 이동
  - Clustered Index가 적용된 속성 값이 변경되면, 데이터의 물리적 저장 위치도 변경되어야 함
  - 속성 변경이 빈번한 경우 성능 저하를 초래
- 테이블당 하나만 생성 가능
  - 물리적 정렬 기준을 한 가지로만 유지할 수 있기 때문에 테이블당 하나의 Clustered Index만 생성 가능
  
 ### 5. Non-Clustered Index
- 별도 인덱스 테이블
  - Non-Clustered Index는 실제 데이터와는 별도로 생성된 인덱스 구조로, 데이터가 저장된 순서에 영향을 미치지 않음
  - 인덱스 테이블에서 필요한 값의 위치를 참조하여 검색 속도를 높이는 방식
- 다수 생성 가능
  - 여러 열에 대해 생성할 수 있어, 검색 요구 사항에 맞추어 다양한 조건으로 효율적인 검색을 지원
- 추가적인 스토리지 필요
  - 별도의 인덱스 테이블을 만들기 때문에 저장공간을 더 많이 차지
  - 유연한 검색 기능 제공
  
 ### 6. Composite Index
- 여러 속성 조합 인덱스
  - 하나의 인덱스에 두 개 이상의 열을 포함하여 특정 조합에 대해 검색 성능을 높이는 인덱스
- 검색 순서의 중요성
  - 인덱스가 설정된 열 순서대로 검색할 때는 성능 향상
  - 특정 열만 사용하여 검색할 때는 인덱스 효과 감소
- 질의 패턴과 인덱스 설계의 관계
  - Composite Index의 유용성은 SELECT 질의의 조건과 열 순서에 따라 달라지므로, 실제 사용 패턴을 고려해 인덱스 설계를 해야 함
  
 ### 7. Index의 성능과 고려 사항
- 인덱스 장점
  - 검색 속도 향상
    - SELECT 쿼리의 검색 성능을 향상
    - 이를 통해 특정 조건의 데이터를 빠르게 찾을 수 있어 조회 속도가 빠름
- 인덱스 단점
  - 쓰기 성능 저하
    - 인덱스를 무분별하게 생성할 경우 데이터 삽입, 수정, 삭제 시 인덱스를 갱신해야 하므로 성능 저하 및 불필요한 디스크 I/O 발생
  - 추가적인 저장 공간 사용
    - 인덱스는 별도의 저장 공간을 필요로 하며, 인덱스가 많을수록 더 많은 공간 차지
- INSERT, DELETE, UPDATE 쿼리에 미치는 영향
  - INSERT
    - 인덱스를 생성하면 데이터가 추가될 때 인덱스에도 데이터를 추가해야 하므로 추가적인 작업 발생
  - DELETE
    - 삭제 시 인덱스에서 데이터를 실제로 제거하는 대신, 단순히 사용하지 않음 표시로 남겨두는 경우가 많음
    - 반복되면 인덱스에 유효하지 않은 데이터가 쌓이면서 성능 저하
  - UPDATE
    - 업데이트는 인덱스에서 이전 데이터를 삭제하고 새로운 데이터를 추가하는 작업을 필요로 하므로 INSERT, DELETE의 문제점이 동시에 발생
    - 자주 업데이트되는 컬럼에 인덱스를 생성하면 비효율
- 범위가 좁은 데이터에 대한 인덱스의 비효율성
  - 범위가 좁은 데이터에는 인덱스가 오히려 비효율적

<br><br>

## 정규화
### 1. 배경
- 정규화는 한 릴레이션에 여러 엔티티의 중복된 정보로 인해 갱신 이상(정보의 일관성 문제)이 발생하고 저장 공간이 낭비되는 문제를 해결하기 위해 등장
- 동일한 정보가 여러 릴레이션에 저장될 경우 일부만 변경 시 일관성을 잃게 되어, 이를 방지하고자 정규화를 수행
- 갱신 이상 유형
  - 삽입 이상
    - 원치 않는 자료가 삽입되거나 자료 부족으로 삽입이 되지 않는 문제
  - 삭제 이상
    - 특정 정보만 삭제하고 싶어도, 해당 정보가 포함된 전체 튜플이 삭제되어 불필요한 정보 손실이 발생
  - 수정(갱신) 이상
    - 일부 데이터만 갱신되거나 잘못 갱신되어 데이터가 일관성을 잃는 문제

### 2. 정규화란?
- 정규화는 데이터 중복을 최소화하고 데이터베이스 구조를 효율적으로 설계하기 위해 릴레이션을 좋은 형태로 분해하는 작업
- 이 과정에서 특정 조건을 만족하는 정규형을 충족하며, 주요 정규형으로는 제 1 정규형 (1NF), 제 2 정규형 (2NF), 제 3 정규형 (3NF), BCNF 등이 있다.
- 나쁜 릴레이션 식별
  - 릴레이션의 함수적 종속성을 확인하여, 특정 정규형 조건을 만족하지 못하면 이를 나쁜 릴레이션으로 간주하고 개선
- 함수적 종속성
  - 특정 속성 집합의 값이 다른 속성 집합의 값을 유일하게 결정할 때 함수적 종속성이 있다고 함
  - 함수적 종속성은 정규화를 판단하고 적용하는 중요한 기준
- 주요 정규형 조건
  - 1NF: 모든 attribute가 원자값을 가짐
  - 2NF: 모든 비주요 속성이 주요 속성에 대해 완전 함수적 종속
  - 3NF: 비주요 속성이 기본키에 대해 이행적으로 종속되지 않음
  - BCNF: 여러 후보 키가 있는 복잡한 관계에서 발생하는 문제를 해결하기 위해 제 3 정규형을 보완한 형태

### 3. 정규화 장점
- 삽입, 삭제, 갱신 시 발생할 수 있는 이상 현상 방지
- 구조 확장 시 재 디자인 최소화
- 의미 있는 데이터 모델 제공

### 4. 정규화 단점
- 정규화로 인해 릴레이션이 분해되면 JOIN 연산이 증가하여 쿼리 응답 속도가 느려질 수 있음
- 데이터 중복 제거로 저장 효율을 높이지만, 일부 쿼리에서는 비정규화된 구조보다 속도가 느려질 수 있음

### 5. 반정규화
- 정규화의 단점을 보완하기 위해 De-normalization(반정규화)가 필요
- 반정규화는 정규화된 엔티티, 속성, 관계를 중복하거나 합쳐 시스템 성능을 높이는 방법
- 조회 시 성능이 중요한 경우, JOIN 연산을 줄이기 위해 일부 테이블을 통합

<br><br>

## Transaction
### 1. 트랜잭션이란?
- 트랜잭션은 작업의 완전성을 보장하는 논리적 단위
- 모든 작업이 성공하거나, 실패 시 원래 상태로 복구
- 사용자에게는 논리적 작업 단위이며, 시스템에게는 데이터 접근 단위

### 2. 트랜잭션과 Lock
- Lock은 동시성 제어를 위한 기능
- 트랜잭션은 데이터의 정합성을 보장하는 기능
- 잠금은 여러 커넥션이 동일 자원에 접근할 때 순서를 지정
- 트랜잭션은 작업 집합이 100% 완료되거나, 아무것도 적용되지 않음
  
### 3. 트랜잭션 특성 (ACID)
- Atomicity(원자성): 트랜잭션 중 문제가 발생하면 모든 작업이 취소
- Consistency(일관성): 트랜잭션 후에도 데이터의 일관성이 유지
- Isonlation(고립성): 각 트랜잭션은 독립적으로 수행
- Durability(지속성): 트랜잭션 완료 후 결과가 영구적으로 저장

### 4. 트랜잭션 상태
- Active: 트랜잭션이 실행 중인 상태
- Failed: 트랜잭션이 더 진행될 수 없는 상태
- Partially Committed: 커밋 요청이 들어온 상태
- Commited: 트랜잭션이 정상적으로 완료된 상태
- Aborted: 트랜잭션이 취소되고 원 상태로 복구된 상태

### 5. 트랜잭션 사용 시 주의사항
- 트랜잭션 범위를 최소화해 커넥션 점유 시간을 줄임

### 6. DeadLock (교착 상태)
- 교착 상태는 두 개 이상의 트랜잭션이 서로의 잠금을 기다릴 때 발생
- 해결방법
  - 트랜잭션을 자주 커밋
  - 테이블 접근 순서를 일관되게 유지
  - SELECT ~ FOR UPDATE와 같은 읽기 잠금 피함
  - 순서 없는 복수 행 갱신 대신 테이블 단위 잠금 사용